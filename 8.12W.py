listing_1 = {
    
        "property_id": 1,
        "location": "Blue Mountain, Ontario",
        "type": "cabin",
        "price_per_night": 140,
        "features": ["mountain view", "fireplace", "ski-in/ski-out", "wifi"],
        "tags": ["mountains", "remote", "adventure"],
        "guest_capacity": 4,
        'unavailable_dates': ['2025-08-15', '2025-08-20', '2025-10-21', '2025-10-22', '2025-10-23']


    }


listing_2 = {
    "property_id": 2,
    "location": "103 Ocean Street West",
    "type" : "Apartment",
    "price_per_night": 65,
    "features" : ["furnished", "on the beach", "open concept"],
    "tags" : ["cozy", "seaside"],
    'guest_capacity': 2,
    'unavailable_dates': ['2025-09-01', '2025-09-02', '2025-09-20', '2025-10-01']
}

listing_3 = {
    "property_id": 3,
    "location": "Niagara-on-the-Lake, Ontario",
    "type": "guesthouse",
    "price_per_night": 95,
    "features": ["wine country view", "garden", "wifi", "bike rentals"],
    "tags": ["romantic", "wine", "culture"],
    'guest_capacity': 2,
    'unavailable_dates': ['2025-09-30', '2025-09-15', '2025-12-20', '2025-12-03']
}

listing_4 = {
    "property_id": 4,
    "location": "Tobermory, Ontario",
    "type": "cottage",
    "price_per_night": 125,
    "features": ["lake view", "kayak included", "fire pit", "wifi"],
    "tags": ["nature", "waterfront", "hiking"],
    'guest_capacity': 3,
    'unavailable_dates': ['2025-10-11', '2025-10-12', '2025-10-13', '2025-12-24', '2025-12-25', '2025-12-26']
}

listing_5 = {
    "property_id": 5,
    "location": "Toronto, Ontario",
    "type": "apartment",
    "price_per_night": 180,
    "features": ["central location", "gym access", "rooftop view", "wifi"],
    "tags": ["city", "nightlife", "foodie"],
    'guest_capacity': 4,
    'unavailable_dates': ['2025-11-19', '2025-11-20', '2025-11-21', '2025-11-27', '2025-11-28']
}
listing_6 = {
        "property_id": 6,
        "location": "Blue Mountain, Ontario",
        "type": "loft",
        "price_per_night": 660,
        "features": ["mountain view", "balcony", "wifi", "hot tub"],
        "tags": ["mountains", "luxury", "ski"],
        'guest_capacity': 8,
        'unavailable_dates': ['2025-10-05']
    }
listing_7 = {
        "property_id": 7,
        "location": "Wasaga Beach, Ontario",
        "type": "villa",
        "price_per_night": 200,
        "features": ["private pool", "beachfront", "AC", "wifi"],
        "tags": ["beach", "luxury", "family"],
        'guest_capacity': 4,
        'unavailable_dates': ['2025-10-17', '2025-10-18', '2025-12-19', '2025-12-20']
    }
listing_8 = {
        "property_id": 8,
        "location": "Niagara-on-the-Lake, Ontario",
        "type": "cottage",
        "price_per_night": 350,
        "features": ["garden", "bike rentals", "fire pit", "wifi"],
        "tags": ["romantic", "nature", "wine"],
        'guest_capacity': 2,
        'unavailable_dates': ['2025-09-12', '2025-09-13', '2026-01-01', '2026-01-02', '2026-01-26']
    }
listing_9 = {
        "property_id": 9,
        "location": "Tobermory, Ontario",
        "type": "tiny house",
        "price_per_night": 90,
        "features": ["lake view", "hiking trails nearby", "BBQ", "wifi"],
        "tags": ["budget", "nature", "waterfront"],
        'guest_capacity': 3,
        'unavailable_dates': ['2025-12-03', '2025-12-19', '2025-12-31', '2026-02-02']
    }
listing_10 = {
        "property_id": 10,
        "location": "Toronto, Ontario",
        "type": "studio",
        "price_per_night": 150,
        "features": ["central location", "AC", "wifi", "workspace"],
        "tags": ["city", "business", "solo travel"],
        'guest_capacity': 2,
        'unavailable_dates': ['2025-11-11', '2025-11-20', '2025-12-04']

    }
listing_11 = {
        "property_id": 11,
        "location": "Muskoka, Ontario",
        "type": "cottage",
        "price_per_night": 770,
        "features": ["lakefront", "canoe included", "fire pit", "wifi"],
        "tags": ["nature", "waterfront", "family"],
        'guest_capacity': 10,
        'unavailable_dates': ['2025-12-12', '2025-12-23', '2025-12-24', '2025-12-28']
    }
listing_12 = {
        "property_id": 12,
        "location": "Prince Edward County, Ontario",
        "type": "guesthouse",
        "price_per_night": 130,
        "features": ["wine country view", "garden", "wifi", "pet friendly"],
        "tags": ["romantic", "wine", "pet friendly"],
        'guest_capacity': 2,
        'unavailable_dates': ['2026-03-01', '2026-03-10', '2025-12-11']
    }
listing_13 = {
        "property_id": 13,
        "location": "Ottawa, Ontario",
        "type": "apartment",
        "price_per_night": 120,
        "features": ["central location", "balcony", "wifi", "parking"],
        "tags": ["city", "history", "budget"],
        'guest_capacity': 3,
        'unavailable_dates':['2025-10-09', '2025-10-11','2025-11-14' ]
    }
listing_14 = {
    "property_id": 14,
    "location": "Algonquin Park, Ontario",
    "type": "cabin",
    "price_per_night": 110,
    "features": ["forest view", "canoe included", "fire pit", "wifi"],
    "tags": ["nature", "hiking", "remote"],
    'guest_capacity': 2,
    'unavailable_dates': ['2025-10-18', '2025-10-19', '2025-11-29']
}

listing_15 = {
    "property_id": 15,
    "location": "Kingston, Ontario",
    "type": "loft",
    "price_per_night": 540,
    "features": ["waterfront view", "balcony", "wifi", "downtown access"],
    "tags": ["city", "romantic", "history"],
    'guest_capacity': 6,
    'unavailable_dates': ['2025-12-03', '2025-12-04', '2025-12-05', '2025-12-08', '2025-12-09', '2025-12-31']
}


class Property:
    def __init__(self, property_id, location, p_type, price_per_night,features,tags, guest_capacity, unavailable_dates):
        self.property_id = property_id
        self.location = location
        self.type = p_type
        self.price_per_night = price_per_night
        self.features = features
        self.tags = tags
        self.guest_capacity = guest_capacity
        self.unavailable_dates = unavailable_dates

    def property_display(self):
        print(f"""
        Property ID: {self.property_id} 
        Property Location: {self.location}
        Property Type: {self.type}
        Price per Night: {self.price_per_night}
        Features: {self.features}
        Tags: {self.tags}
        Guest Capacity: {self.guest_capacity}
        Unavailable Dates: {self.unavailable_dates}""")

    def to_dict(self):
        return {
            "property_id": self.property_id,
            "Property Location": self.location,
            "Property Type": self.type,
            "Price per Night": self.price_per_night,
            "Features": self.features,
            "Tags": self.tags,
            "Guest Capacity": self.guest_capacity,
            "Unavailable Dates": self.unavailable_dates
        }
    @classmethod
    def from_dict(cls, d): 
        return cls(
            property_id=d["property_id"],
            location=d["Property Location"],
            p_type=d["Property Type"],
            price_per_night=d["Price per Night"],
            features=d["Features"],
            tags=d["Tags"],
            guest_capacity=d["Guest Capacity"],
            unavailable_dates=d["Unavailable Dates"]    
        )

property_listings = [listing_1, listing_2, listing_3, listing_4, listing_5, listing_6, listing_7, listing_8, listing_9, listing_10, listing_11, listing_12, listing_13, listing_14, listing_15]


property_obj_list = []  
for listings in property_listings:
    property_obj_list.append(Property(listings.get('property_id'),listings.get('location'),listings.get('type'),listings.get('price_per_night'),listings.get('features'),listings.get('tags'),listings.get('guest_capacity'),listings.get('unavailable_dates')))



users_list = [
    {"user_id": 1, "name": "Alice", "group_size": 2, "preferred_environment": "beach", "budget_range": [100,200], 'travel_dates': ['2025-08-15', '2025-08-20']}, #travel dates I mean from 2025-08-15 to 2025-08-20
    {"user_id": 2, "name": "Bob", "group_size": 4, "preferred_environment": "mountains", "budget_range": [200,350], 'travel_dates': ['2025-10-15', '2025-11-02']},
    {"user_id": 3, "name": "Charlie", "group_size": 1, "preferred_environment": "city", "budget_range": [80, 150], 'travel_dates': ['2026-01-01', '2026-02-01']},
    {"user_id": 4, "name": "Diana", "group_size": 3, "preferred_environment": "countryside", "budget_range": [300,500], 'travel_dates': ['2025-12-05', '2025-12-12']},
    {"user_id": 5, "name": "Ethan", "group_size": 5, "preferred_environment": "beach", "budget_range": [250,400], 'travel_dates': ['2025-12-25', '2026-01-20']},
    {"user_id": 6, "name": "Fiona", "group_size": 2, "preferred_environment": "desert", "budget_range": [140,250], 'travel_dates': ['2025-09-20', '2025-09-25']},
    {"user_id": 7, "name": "George", "group_size": 6, "preferred_environment": "mountains", "budget_range": [300,500], 'travel_dates': ['2025-09-23', '2025-09-26']},
    {"user_id": 8, "name": "Hannah", "group_size": 3, "preferred_environment": "city", "budget_range": [170,300], 'travel_dates': ['2026-03-19', '2025-03-22']},
    {"user_id": 9, "name": "Isaac", "group_size": 4, "preferred_environment": "countryside", "budget_range": [210,350], 'travel_dates': ['2026-04-26', '2026-05-01']},
    {"user_id": 10, "name": "Julia", "group_size": 2, "preferred_environment": "beach", "budget_range": [160,280], 'travel_dates': ['2025-11-25', '2025-11-27']},
    {"user_id": 11, "name": "Kevin", "group_size": 1, "preferred_environment": "desert", "budget_range": [110,200], 'travel_dates': ['2025-09-05', '2025-09-07']},
    {"user_id": 12, "name": "Laura", "group_size": 5, "preferred_environment": "mountains", "budget_range": [260,450], 'travel_dates': ['2025-11-21', '2025-11-30']},
    {"user_id": 13, "name": "Michael", "group_size": 3, "preferred_environment": "city", "budget_range": [190,320], 'travel_dates': ['2025-12-06', '2025-12-16']},
    {"user_id": 14, "name": "Nina", "group_size": 4, "preferred_environment": "countryside", "budget_range": [220,380], 'travel_dates': ['2026-03-15', '2026-03-17']},
    {"user_id": 15, "name": "Oscar", "group_size": 2, "preferred_environment": "beach", "budget_range": [130,230], 'travel_dates': ['2026-01-15', '2026-01-20']}

]

class User:
    def __init__(self,user_id, name, group_size, preferred_features, preferred_tags, budget_range, travel_dates):
        self.user_id = user_id
        self.name = name
        self.group_size = group_size
        self.preferred_features = preferred_features
        self.preferred_tags = preferred_tags
        self.budget_range = budget_range
        self.travel_dates = travel_dates
    
    def to_dict(self):
        return {
            "user_id": self.user_id,
            "name": self.name,
            "group_size": self.group_size,
            "preferred_features": self.preferred_features,
            "preferred_tags": self.preferred_tags,
            "budget_range": self.budget_range,
            "travel_dates": self.travel_dates
        }
    
    @classmethod
    def from_dict(cls, d): 
        return cls(
            user_id=d["user_id"],
            name=d["name"],
            group_size=d["group_size"],
            preferred_features=d["preferred_features"],
            preferred_tags=d["preferred_tags"],
            budget_range=d["budget_range"],
            travel_dates=d["travel_dates"]
        )


    def user_display_profile(self):
        print(f"""
        User ID: {self.user_id}
        User Name: {self.name}
        Group Size: {self.group_size}
        Preferred Features: {self.preferred_features}
        Preferred Tags: {self.preferred_tags}
        Budget: {self.budget_range}
        Travel Dates: {self.travel_dates}""")


import datetime

def validate_date(date_str): #Validate if a string is in YYYY-MM-DD format
    try:
        datetime.datetime.strptime(date_str, '%Y-%m-%d')
        return True
    except ValueError:
        return False

def create_user_profile():
    print("\n=== CREATE NEW PROFILE ===")
    user_id = len(users_obj_list) + 1
    
    while True:
        name = input("Full Name: ").strip()
        if name: break
        print("Name cannot be empty")
    
    while True:
        try:
            group_size = int(input("Group Size: "))
            if group_size > 0: break
            print("Must be positive number")
        except ValueError:
            print("Please enter a whole number")
    while True:
        try:
            min_budget = float(input("Minimum Budget ($) - whole number only: "))
            if min_budget != int(min_budget):
                print("Please enter a whole number (no decimals)")
                continue
            min_budget = int(min_budget)
            if min_budget <= 0:
                print("Minimum budget must be positive")
                continue
            break
        except ValueError:
            print("Please enter a whole number")
    
    while True:
        try:
            max_budget = float(input("Maximum Budget ($) - whole number only: "))
            if max_budget != int(max_budget):
                print("Please enter a whole number (no decimals)")
                continue
            max_budget = int(max_budget)
            if max_budget <= 0:
                print("Maximum budget must be positive")
                continue
            if max_budget < min_budget:
                print("Maximum budget must be greater than or equal to minimum budget")
                continue
            break
        except ValueError:
            print("Please enter a whole number")
    
    # Get preferred features
    print("\nEnter your preferred features (at least one required):")
    print("Examples: wifi, fireplace, pool, beachfront, mountain view, etc.")
    print("Press Enter when you're done adding features")
    preferred_features = []
    while True:
        feature = input("Add feature: ").strip().lower()
        if not feature:
            if not preferred_features:
                print("Please enter at least one feature")
                continue
            else:
                print(f"Features added: {preferred_features}")
                break
        preferred_features.append(feature)
        print(f"Added: {feature}")
    
    # Get preferred tags
    print("\nEnter your preferred tags (at least one required):")
    print("Examples: beach, luxury, budget, family, adventure, etc.")
    print("Press Enter when you're done adding tags")
    preferred_tags = []
    while True:
        tag = input("Add tag: ").strip().lower()
        if not tag:
            if not preferred_tags:
                print("Please enter at least one tag")
                continue
            else:
                print(f"Tags added: {preferred_tags}")
                break
        preferred_tags.append(tag)
        print(f"Added: {tag}")
    
    
    travel_dates = []
    print("\nEnter Start Date of Travel (YYYY-MM-DD format): ")
    
    while True:
        start_date = input("Start date: ").strip()
        if not start_date:
            print("Start date is required")
            continue
        if validate_date(start_date):
            break
        else:
            print("Invalid format. Use YYYY-MM-DD")
    
    while True:
        end_date = input("End date (YYYY-MM-DD format): ").strip()
        if not end_date:
            print("End date is required")
            continue
        if validate_date(end_date):
            # Check if end date is after start date
            if datetime.datetime.strptime(end_date, '%Y-%m-%d') <= datetime.datetime.strptime(start_date, '%Y-%m-%d'):
                print("End date must be after start date")
                continue
            break
        else:
            print("Invalid format. Use YYYY-MM-DD")
    
    travel_dates = [start_date, end_date]
    
    new_user = User(user_id, name, group_size, preferred_features, preferred_tags,
                   [min_budget, max_budget], travel_dates)
    users_obj_list.append(new_user)
    print(f"\nProfile created successfully! User ID: {user_id}")
    return new_user

def view_user_profile(user_id):
    for user in users_obj_list:
        if user.user_id == user_id:
            user.user_display_profile()
            return user
    print(f"No user found with ID {user_id}")
    return None

def delete_profile(user_id):
    global users_obj_list
    for i, user in enumerate(users_obj_list):
        if user.user_id == user_id:
            users_obj_list.pop(i)
            print(f"Deleted user ID {user_id}")
            return
    print(f"No user found with ID {user_id}")

def edit_user_profile(user_id):
    user_to_edit = None
    for user in users_obj_list:
        if user.user_id == user_id:
            user_to_edit = user
            break
    
    if not user_to_edit:
        print(f"No user found with ID {user_id}")
        return None
    
    while True:
        print(f"\n=== EDITING PROFILE FOR USER {user_id} ===")
        print("Current profile:")
        user_to_edit.user_display_profile()
        
        print("\nWhat would you like to edit?")
        print("1. Name")
        print("2. Group Size")
        print("3. Budget Range")
        print("4. Travel Dates")
        print("5. Preferred Features")
        print("6. Preferred Tags")
        print("7. Done (Exit)")
        
        while True:
            try:
                choice = int(input("Enter your choice (1-7): "))
                print(f"You entered: {choice}")
                if 1 <= choice <= 7:
                    break
                print("Please enter a number between 1 and 7")
            except ValueError:
                print("Please enter a number")
        
        if choice == 7:
            print("Edit session completed")
            break
        
        print(f"Processing choice: {choice}")
        
        if choice == 1:
            while True:
                new_name = input("Enter new name: ").strip()
                if new_name:
                    user_to_edit.name = new_name
                    print("Name updated successfully!")
                    break
                print("Name cannot be empty")
        
        elif choice == 2:
            print("You chose to edit group size")
            while True:
                try:
                    new_group_size = int(input("Enter new group size: "))
                    if new_group_size > 0:
                        user_to_edit.group_size = new_group_size
                        print("Group size updated successfully!")
                        break
                    print("Group size must be positive")
                except ValueError:
                    print("Please enter a whole number")
        
        elif choice == 3:
            print("Enter new budget range:")
            while True:
                try:
                    new_min_budget = float(input("Minimum Budget ($) - whole number only: "))
                    if new_min_budget != int(new_min_budget):
                        print("Please enter a whole number")
                        continue
                    new_min_budget = int(new_min_budget)
                    if new_min_budget <= 0:
                        print("Minimum budget must be positive")
                        continue
                    break
                except ValueError:
                    print("Please enter a whole number")
            
            while True:
                try:
                    new_max_budget = float(input("Maximum Budget ($) - whole number only: "))
                    if new_max_budget != int(new_max_budget):
                        print("Please enter a whole number")
                        continue
                    new_max_budget = int(new_max_budget)
                    if new_max_budget <= 0:
                        print("Maximum budget must be positive")
                        continue
                    if new_max_budget < new_min_budget:
                        print("Maximum budget must be greater than or equal to minimum budget")
                        continue
                    break
                except ValueError:
                    print("Please enter a whole number")
            
            user_to_edit.budget_range = [new_min_budget, new_max_budget]
            print("Budget range updated successfully!")
        
        elif choice == 4:
            print("Enter new travel dates:")
            while True:
                start_date = input("Start date (YYYY-MM-DD): ").strip()
                if not start_date:
                    print("Start date is required")
                    continue
                if validate_date(start_date):
                    break
                else:
                    print("Invalid format. Use YYYY-MM-DD")
            
            while True:
                end_date = input("End date (YYYY-MM-DD): ").strip()
                if not end_date:
                    print("End date is required")
                    continue
                if validate_date(end_date):
                    if datetime.datetime.strptime(end_date, '%Y-%m-%d') <= datetime.datetime.strptime(start_date, '%Y-%m-%d'):
                        print("End date must be after start date")
                        continue
                    break
                else:
                    print("Invalid format. Use YYYY-MM-DD")
            
            user_to_edit.travel_dates = [start_date, end_date]
            print("Travel dates updated successfully!")
        
        elif choice == 5:
            print("Enter new preferred features (at least one required):")
            print("Press Enter when you're done adding features")
            new_features = []
            while True:
                feature = input("Add feature: ").strip().lower()
                if not feature:
                    if not new_features:
                        print("Please enter at least one feature")
                        continue
                    else:
                        print(f"Features added: {new_features}")
                        break
                new_features.append(feature)
                print(f"Added: {feature}")
            
            user_to_edit.preferred_features = new_features
            print("Preferred features updated successfully!")
        
        elif choice == 6:
            print("Enter new preferred tags (at least one required):")
            print("Press Enter when you're done adding tags")
            new_tags = []
            while True:
                tag = input("Add tag: ").strip().lower()
                if not tag:
                    if not new_tags:
                        print("Please enter at least one tag")
                        continue
                    else:
                        print(f"Tags added: {new_tags}")
                        break
                new_tags.append(tag)
                print(f"Added: {tag}")
            
            user_to_edit.preferred_tags = new_tags
            print("Preferred tags updated successfully!")
        
        # Show updated profile after any edit
        print("\nUpdated profile:")
        user_to_edit.user_display_profile()
        print("Update completed! You can continue editing or choose option 7 to exit.")
    
    return user_to_edit



users_obj_list = []  
for users in users_list:
    users_obj_list.append(User(users.get('user_id'),users.get('name'),users.get('group_size'),users.get('preferred_features'),users.get('preferred_tags'),users.get('budget_range'),users.get('travel_dates')))

for user in users_obj_list:
    user.user_display_profile()

for listing in property_obj_list:
    listing.property_display()

